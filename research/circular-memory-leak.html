<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>Circular Memory Leak</title>

    <style type="text/css">
        .warningMessage {
            border: 10px solid red;
            padding: 10px;
        }
    </style>

</head>
<body>

    <h1>Circular Memory Leak</h1>

    <noscript>
        <p class="warningMessage">JavaScript not enabled in this browser.</p>
    </noscript>

    <p>Click start and watch memory usage of the browser in the operating system. In IE6, for example, the memory usage should increase monotonically. After clicking the stop link, the memory use should plateau and only start increasing again after clicking start again. The memory use of the OS will only garbage collect when IE6 is closed if Windows XP Service Pack 3 (SP3) is not installed. If SP3 is installed then apparently the memory should be garbage collected when the page is unloaded (i.e. refreshing the browser or navigating to another web page.) I don't have SP3 and so have not confirmed this.</p>

    <p>Another test can be performed to see the solution to the circular memory leak problem. Click start and watch memory usage of the browser in the operating system. In IE6, for example, the memory usage should increase monotonically. After clicking the break memory loop "true" link, the memory use should plateau. Although more DOM nodes and event handlers are created after clicking the break memory loop "true" link, these new DOM nodes are not kept in the handler functions' closures. If you then click the break memory loop "false" link, the memory use should start growing again.</p>
    
    <p>You can also choose a different DOM model to use. It is recommended that you change the DOM model <strong>before</strong> clicking the start link and then don't change the DOM model again. If you know how to interpret the results while changing the DOM model while the test is running then you can.</p>

    <script type="text/javascript">
        // Build a big string that can be used to create
        // big memory garbage.
        var bigString = (function() {
            var littleString = 'abcdefghijklmnopqrstuvwxyz';
            var growingString = '';
            for (var i = 0; i < 10000; i++) {
                growingString += littleString;
            }
            return growingString;
        }());
    </script>

    <p>Choose DOM model: (currently using "<span id="domModelReporter"></span>")</p>

    <script type="text/javascript">

        var domModel;
        function setDomModel(dm) {
            domModel = dm;
            document.getElementById('domModelReporter').innerHTML = domModel;
        }
        setDomModel('DOM0');

    </script>

    <ul>
        <li><a href="#DOM0" onclick="setDomModel('DOM0');return false;">DOM0</a></li>
        <li><a href="#IE"   onclick="setDomModel('IE');return false;">IE</a></li>
        <li><a href="#DOM2" onclick="setDomModel('DOM2');return false;">DOM2</a></li>
    </ul>

    <p>Set break memory loop: (currently set to "<span id="breakMemoryLoopReporter"></span>")</p>

    <script type="text/javascript">
        
        var breakMemoryLoop;
        function setBreakMemoryLoop(bool) {
            breakMemoryLoop = bool;
            document.getElementById('breakMemoryLoopReporter').innerHTML = breakMemoryLoop;
        }
        setBreakMemoryLoop(false);

    </script>

    <ul>
        <li><a href="#break-memory-loop-falue" onclick="setBreakMemoryLoop(false);return false;">false</a></li>
       <li><a href="#break-memory-loop-true" onclick="setBreakMemoryLoop(true);return false;">true</a></li>
    </ul>

    <p>Running indicator: <span id="runningReporter"></span></p>

    <script type="text/javascript">
    
        function createMemoryLoop(i) {
            // The "el" element is only referenced locally in this function.
            // When this function returns, the "el" element should be 
            // garbage collected.
            var el = document.createElement('p');
            
            // Add something big and unique to the closure. The i at the
            // beginning and end are to avoid the browser using some
            // clever reuse of strings.
            var html = i + bigString + i;
            
            // Create a circular reference. The event handler has
            // the "el" element in its closure but not explicitely used
            // inside the handler.
            var handler = function() {
                // The body of this event handler will never execute
                // but we want to ensure that html is captured in closure
                // in a meaninful way so the browser doesn't do any
                // clever closure optimizations. If html was not used
                // in this closure then the browser might allow it to be
                // garbage collected.
                alert(html);
            };
            
            if (domModel === 'DOM0') {
                el.onclick = handler;
            }
            else if (domModel === 'IE') {
                el.attachEvent('onclick', handler);
            }
            else if (domModel === 'DOM2') {
                el.addEventListener('click', handler, false);
            }
            else {
                alert('error: unknown domModel "'+domModel+'".');
            }
            
            if (breakMemoryLoop) {
                el = null;
            }
        }

        var throbber = '.';
        function updateRunningReporter(i) {
             // Don't want to update reporter every iteration. That is 
             // unnecessary, too much
             // DOM manipulation and to frantic for a human to watch.
            if (i % 10 === 0) {
                var reporter = document.getElementById('runningReporter');
                // Don't want the reporter to grow indefinitely so occasionally
                // clear it and start growing again.
                throbber = (i % 500 === 0) ? '.' : (throbber + '.');
                reporter.innerHTML = throbber;
            }
        }

        var timeout;
        function iterate(i) {
            createMemoryLoop(i);
            updateRunningReporter(i);
            // Use setTimeout to avoid long running script warning alerts
            // since we specifically want this to just keep going and going.
            //
            // Use a string as the first argument to setTimeout to avoid
            // any unknown closure issues the browser may have.
            timeout = setTimeout('iterate('+(i+1)+')', 10);
        }

        function start() {
            iterate(0);
        }

        function stop() {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
        }
        
    </script>

    <p><a href="#start" onclick="start();return false;">start</a></p>
    <p><a href="#stop" onclick="stop();return false;">stop</a></p>

</body>
</html>
